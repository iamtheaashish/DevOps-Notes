This text document is about Git commands,
covering various aspects of using Git for version control, including basic commands, branching, merging,
and collaboration workflows.

Why DevOps Engineers should learn Git?
Developers have to push code to repositories like GitHub, GitLab, or Bitbucket.
But as a DevOps Engineer, you need to push automation scripts, configuration files, and other resources to these repositories.

* Why is Git important, what problems does it solve?
- There was a problem before Git was invented,
- when multiple developers worked on the same codebase,
- they faced issues with version control, conflicts, and collaboration.

- For example, if two developers edited the same file simultaneously,
- it was difficult to merge their changes without losing work.

- For example, if one developer added a new feature while another fixed a bug,
- they might overwrite each other's changes, leading to lost work and confusion.

- For example, if a developer accidentally deleted a file,
- it was hard to recover the previous version without a proper version control system.

- For example, if a developer wanted to experiment with a new feature,
- they had to create a separate copy of the codebase, which was inefficient and error-prone.

- Git solves these problems by providing a distributed version control system,
- allowing developers to work on their own copies of the codebase,
- track changes, and collaborate effectively without losing work.

* Difference between Git and GitHub:
- Git is a version control system that allows developers to track changes in their codebase, manage
- versions, and collaborate with others. Doesn't have GUI, it is a command line tool.

- GitHub is a web-based Source Code Management platform that provides hosting for Git repositories,
- allowing developers to share their code, collaborate on projects, and manage issues. It has a GUI and provides additional features.

`Git Commands`
=======================
$ dnf install git
$ git --version

" To practice Git commands, we are following these steps: "
$ cd ~/Desktop
$ mkdir facebookmicroservices # Suppose it is our project name 
$ cd facebookmicroservices
$ git init # Creates a new Git empty local repository. A normal directory is converted into a local Git repository. Git tracks all changes in this directory.
$ ls -la # Lists all files in the current directory, even the hidden ones. You can see the .git directory created by git init. That directory contains all the metadata for the repository.

* git init creates three logical areas (you don't see them with your eyes but they exist):
1. Working Area 
   - This is where you make changes to your files.
   - It contains the actual files you are working on.
2. Staging Area 
   - This is where you prepare files to be committed.
   - It acts as a buffer between the working area and the repository.
3. Local Repo 
   - This is where your committed files are stored.
   - It contains the history of all changes made to the files.

" To understand them let's create few files "
$ touch DBUtils.java
$ touch StringUtils.java
$ touch deploy.sh
# Now we have two files in our working area. Let's check the status of our repository.
$ git status
# This command shows the current status of the repository, including untracked files, changes to be committed, and changes not staged for commit.
# The output will show that we have two untracked files: DBUtils.java and StringUtils.java.
# Untracked files are files that are not yet being tracked by Git.

Working Area                    Staging Area                    Local Repo 
=============                   =================               ==============
DBUtils.java (untracked)        (empty)                          (empty)
StringUtils.java (untracked)    (empty)                          (empty)
deploy.sh (untracked)           (empty)                          (empty)

$ git add . # Adds all files in the working area to the staging area.
$ git add *.java # Adds all files with the .java extension to the staging area.
$ git add StringUtils.java # Adds only StringUtils.java to the staging area. 
# The git add command stages changes in the working area, moving them to the staging area.
# The dot (.) means all files, and the asterisk (*) is a wildcard that matches all files with the .java extension.
# After running git add, the files are now in the staging area, ready to be committed. 

$ git status # Check the status again
# The output will now show that the files are staged for commit.

Working Area                    Staging Area                    Local Repo 
=============                   =================               ==============
DBUtils.java (untracked)        DBUtils.java (staged)           (empty)
StringUtils.java (untracked)    StringUtils.java (staged)       (empty)
deploy.sh (untracked)           (empty)                         (empty)

$ git commit -m "First commit" # Commits the staged changes to the local repository with a message.
# The -m option allows you to add a commit message directly in the command line. 
# This command adds all the file to in staged area to the local repository. 
$ git commit -m "Added DBUtils" DBUtils.java # Commits only the DBUtils.java file with a specific message.
$ git status # Check the status again

Working Area                    Staging Area                    Local Repo 
=============                   =================               ==============
DBUtils.java (untracked)        (empty)                         DBUtils.java (committed)
StringUtils.java (untracked)    StringUtils.java (staged)       (empty)
deploy.sh (untracked)           (empty)                         (empty)

===============================================================================================
- Before executing git commit command, you should use the following command to set your username and email.
- This information will be associated with your commits, allowing others to see who made the changes.
$ git config --global user.name "iamtheaashish" # Sets the global username for Git commits.
$ git config --global user.email "iamtheaashish@hotmail.com" # Sets the global email for Git commits.
$ git config --global --list # Lists all global Git configurations. 
"This is only one time setup, you don't need to do it again unless you want to change your username or email."
================================================================================================
$ git remote add <remote_name> <remote_url> # Adds a remote repository to your local repository.
# The remote_name is a nickname for the remote repository, and remote_url is the URL of the remote repository.
For example:
$ git remote add sensors https://github.com/rsa7061-org/sensors.git
# This command adds a remote repository named "sensors" with the specified URL.
# This command maps the remote repository to your local repository, allowing you to push and pull changes between them.
- Sensors is alias name for the remote repository. And the URL is the location of the remote repository on GitHub.

$ git remote -v # Lists all remote repositories associated with your local repository.
# The -v option shows the URLs of the remote repositories along with their names.

$ git push <remote_name> <branch_name> # Pushes changes from your local repository to the remote repository.
# The remote_name is the name of the remote repository, and branch_name is the name of the branch you want to push.
For example:
$ git push sensors main # Pushes changes from the local main branch to the remote sensors repository
# If the remote repository does not have a main branch, it will create one.
# It will ask for your GitHub username and password or personal access token (PAT) for authentication. We can generate a PAT from GitHub settings.
# A PAT is a secure way to authenticate with GitHub without using your password.
# You can generate a PAT from your GitHub account settings under Developer settings > Personal access tokens.
# As soon as you generate a PAT, you have to save it in a secure place, as you won't be able to see it again.
- Sensors is alias name for the remote repository, And main is the name of the branch you want to push.
=============================================================================================

"Git can only be used with GitHub, GitLab, Bitbucket or Azure DevOps repositories."
"SVN (Subversion) is a different version control system and is not compatible with Git."
"With SVN, we have to use SVN client instead of Git."

===============================================================================================
* Difference between Git and SVN:
- Git is a distributed version control system, meaning each developer has a complete copy of the repository
- on their local machine, allowing them to work offline and commit changes locally before pushing to a
- central repository. Git tracks changes in files and allows for branching and merging, making it easier
- to collaborate on projects with multiple developers.   

- SVN (Subversion) is a centralized version control system, meaning there is a single central repository
- that all developers access to commit changes. SVN tracks changes in files and directories, but it
- does not support branching and merging as effectively as Git. SVN is more suitable for projects with
- a single central repository and fewer developers, as it can be more difficult to manage changes
- and collaborate on projects with multiple developers.  






